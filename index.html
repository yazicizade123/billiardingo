<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3-Cushion Billiards Game</title>
    <!-- Tailwind CSS CDN for responsive and modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the game to ensure full screen mobile experience */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            user-select: none;
            overflow: hidden; /* Prevent scrolling on mobile */
        }

        /* Ana Konteyner: Tüm Oyun İçeriği Burada Olacak */
        #gameContainer {
            width: 100vw;
            height: 100vh;
            max-width: 900px; 
            max-height: 900px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        /* --- OYUN ALANI (Masa + Kontroller) --- */
        /* Bu, masayı ve yan kontrolleri yan yana tutar */
        #gameArea {
            display: flex;
            align-items: center; 
            justify-content: center;
            width: 100%;
            height: 100%;
            padding: 10px; /* Kenar boşluğu */
            box-sizing: border-box;
            position: relative;
        }
        
        /* --- YENİ BİLARDO MASASI ÇERÇEVESİ (AHŞAP GÖRÜNÜM) --- */
        #tableFrame {
            position: relative; 
            /* Boyutları JS tarafından ayarlanacak */
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.8), inset 0 0 50px rgba(0, 0, 0, 0.5); /* Derinlik ve Gölge */
            border-radius: 8px;
            background-color: #5C3317; /* Koyu Ahşap Rengi */
            padding: 20px; /* CANVAS ile çerçeve arasındaki kalınlık */
            transition: all 0.3s ease;
            flex-shrink: 0; /* Boyutunu korumasını sağla */
        }
        
        /* Canvas for the Billiards Table */
        #billiardsCanvas {
            /* Çerçevenin içindeki yastık (bant) ve kumaş rengi */
            background-color: #034827; /* Green cloth (Kumaş) */
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.7); /* Kumaşa derinlik kat */
            border-radius: 4px; /* Köşelerin yuvarlatılması */
            touch-action: none; 
            display: block;
        }
        
        /* Çivi Stili */
        .nail {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #9E9E9E; /* Gri metal */
            box-shadow: 
                0 1px 1px rgba(0, 0, 0, 0.5), /* Hafif gölge */
                inset 0 0 3px #E0E0E0, /* Işık parlaması */
                inset 0 -1px 1px #555; /* Derinlik */
            z-index: 10;
        }
        
        /* Çivilerin Konumları (CSS ile yerleştirilecek - Konumlar % ile daha dinamik) */
        .nail.top-left { top: 8px; left: 8px; }
        .nail.top-center-1 { top: 8px; left: 35%; transform: translateX(-50%); }
        .nail.top-center-2 { top: 8px; left: 65%; transform: translateX(-50%); }
        .nail.top-right { top: 8px; right: 8px; }
        .nail.bottom-left { bottom: 8px; left: 8px; }
        .nail.bottom-center-1 { bottom: 8px; left: 35%; transform: translateX(-50%); }
        .nail.bottom-center-2 { bottom: 8px; left: 65%; transform: translateX(-50%); }
        .nail.bottom-right { bottom: 8px; right: 8px; }
        .nail.left-top { top: 25%; left: 8px; transform: translateY(-50%); }
        .nail.left-bottom { bottom: 25%; left: 8px; transform: translateY(50%); }
        .nail.right-top { top: 25%; right: 8px; transform: translateY(-50%); }
        .nail.right-bottom { bottom: 25%; right: 8px; transform: translateY(50%); }
        .nail.left-center { top: 50%; left: 8px; transform: translateY(-50%); }
        .nail.right-center { top: 50%; right: 8px; transform: translateY(-50%); }
        
        /* Kontrol Konteyneri: Masanın SAĞINDA yer alacak ve esnek boyutta olacak */
        .game-controls-container {
            width: 80px; /* Kontroller için sabit genişlik */
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding-top: 50px; /* Üst kontrol butonları için boşluk */
            box-sizing: border-box;
            pointer-events: none; /* Kontrol dışı alanlar tıklanabilir olmalı */
            flex-shrink: 0; /* Boyutu sıkıştırılmasın */
        }
        
        /* İsteka (Power Bar) */
        #powerBarContainer {
            position: relative; 
            width: 38px; 
            height: 45%; /* Masanın yüksekliğinin %45'i kadar yükseklik */
            min-height: 200px;
            max-height: 400px;
            background-color: #222; 
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #000; 
            z-index: 100;
            display: none; 
            cursor: pointer; 
            touch-action: none; 
            padding: 5px 2px; 
            box-sizing: border-box; 
            
            box-shadow: 
                -10px 0 0 0 #4B3322, 
                -10px 0 0 1px #111,  
                0 0 20px rgba(0, 0, 0, 0.9); 
            pointer-events: auto; /* Tıklanabilir */
        }

        /* English Selector */
        #englishSelector {
            position: relative;
            margin-top: 20px;
            width: 60px; 
            height: 60px; 
            background-color: transparent; 
            border: none; 
            cursor: pointer;
            z-index: 100;
            display: none; 
            padding: 0;
            pointer-events: auto; /* Tıklanabilir */
        }

        /* Kontrol Düğmeleri (Pause/Retry) */
        #gameControls {
            position: absolute;
            top: 10px; 
            right: 10px; 
            z-index: 500;
        }
        
        /* --- GİZLE/GÖSTER KONTROLÜ (MENÜLER) --- */
        /* Menü konteyneri, masanın üstünü kaplar ve masayı gizler */
        #screenContainer {
            position: absolute;
            inset: 0;
            width: 100vw; 
            height: 100vh; 
            display: flex; 
            align-items: center; 
            justify-content: center;
            z-index: 200; /* Masanın üstünde */
            transition: opacity 0.3s ease;
        }

        /* --- DİĞER MENÜ VE BUTON STİLLERİ AYNEN KALACAK --- */
        
        #powerBarFill {
            width: 100%;
            height: 0%; 
            position: absolute;
            bottom: 0; 
            transition: height 0.05s ease-out, background-color 0.2s;
            z-index: 101; 
        }
        
        #cueHandle {
            position: absolute;
            bottom: 5px; 
            left: 2px;
            width: 34px; 
            height: calc(100% - 10px); 
            display: flex;
            justify-content: center;
            align-items: flex-start; 
            touch-action: none; 
            z-index: 103; 
            pointer-events: none; 
            transition: transform 0.05s ease-out; 
            transform: translateY(0px); 
        }

        #cueHandle svg {
            width: 8px; 
            height: 100%; 
        }

        #powerMarkings {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px 5px;
            z-index: 102;
            pointer-events: none;
        }

        .marking-line {
            height: 1px;
            background-color: #666;
            width: 100%;
            position: relative;
        }
        
        .marking-line::before, .marking-line::after {
            content: '';
            position: absolute;
            height: 1px;
            background-color: #A0A0A0; 
            top: 0;
        }
        
        .marking-line::before {
            left: 0;
            width: 30%;
        }
        .marking-line::after {
            right: 0;
            width: 30%;
        }
        
        /* Diğer menü stilleri (game-button, menu-fullscreen vb.) aynen kaldı */
        
        .menu-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; 
            text-align: center;
            position: relative;
            overflow-y: auto;
            color: white; 
            background-color: #104C33; 
        }
        
        .menu-fullscreen {
            width: 100vw; 
            height: 100vh; 
            padding-top: 5rem; 
            padding-bottom: 5rem;
            box-sizing: border-box;
            border: none;
            box-shadow: none;
        }

        .menu-standard {
            width: 95%; 
            max-width: 500px; 
            min-height: 80vh; 
            max-height: 90vh;
            border: 10px solid #5A3F2C; 
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
            border-radius: 12px;
            padding: 2rem;
            justify-content: center; 
        }
        
        .game-button {
            width: 90%; 
            max-width: 350px;
            padding: 16px 24px; 
            margin: 15px 0; 
            border-radius: 12px;
            font-size: 1.5rem; 
            font-weight: 800; 
            color: white;
            text-shadow: 0 2px 3px rgba(0, 0, 0, 0.5);
            background-color: #FF8C00; 
            border: none;
            box-shadow: 
                0 6px 0 0 #D06C00, 
                0 8px 15px rgba(0, 0, 0, 0.4); 
            transition: all 0.1s ease-out;
            cursor: pointer;
        }

        .game-button:hover {
            background-color: #FFA500;
            transform: translateY(-2px); 
            box-shadow: 
                0 4px 0 0 #D06C00, 
                0 10px 20px rgba(0, 0, 0, 0.6);
        }

        .game-button:active {
            transform: translateY(4px); 
            box-shadow: 
                0 2px 0 0 #D06C00, 
                0 8px 10px rgba(0, 0, 0, 0.3);
        }
        
        .standard-button {
            padding: 12px 24px; 
            border-radius: 12px;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
            cursor: pointer;
            background-color: #4f46e5;
            color: white;
            border: none;
            margin: 8px 0; 
            font-size: 1.1rem;
            width: 90%; 
            max-width: 350px;
            transition: all 0.1s;
        }
        
        .standard-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.5);
        }

        .game-control-button {
            width: 40px;
            height: 40px;
            padding: 0;
            background-color: rgba(0, 0, 0, 0.4); 
            color: #fff;
            font-size: 1.5rem;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%; 
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
    </style>
</head>
<body>

<div id="gameContainer" class="p-4 sm:p-8">
    
    <!-- Ana Oyun Alanı (Masa ve Yan Kontrollerin Konteyneri) -->
    <!-- Bu div, masanın ve yan kontrollerin yan yana durmasını sağlar -->
    <div id="gameArea" style="display: none;"> 
        
        <!-- YENİ AHŞAP ÇERÇEVE KONTEYNERİ -->
        <div id="tableFrame">
            <!-- Metal Çivi Görselleri (CSS ile konumlanmış) -->
            <div class="nail top-left"></div>
            <div class="nail top-center-1"></div>
            <div class="nail top-center-2"></div>
            <div class="nail top-right"></div>
            
            <div class="nail bottom-left"></div>
            <div class="nail bottom-center-1"></div>
            <div class="nail bottom-center-2"></div>
            <div class="nail bottom-right"></div>
            
            <div class="nail left-top"></div>
            <div class="nail left-center"></div>
            <div class="nail left-bottom"></div>
            
            <div class="nail right-top"></div>
            <div class="nail right-center"></div>
            <div class="nail right-bottom"></div>
            
            <!-- Game Canvas (İçinde Sadece Kumaş ve Bant Çizilecek) -->
            <canvas id="billiardsCanvas"></canvas>
        </div>
        
        <!-- Kontrol Butonları ve Güç Çubuğu Konteyneri (Sağ Kenar) -->
        <div class="game-controls-container">
            <!-- Dikey Güç İstekası (Power Bar) -->
            <div id="powerBarContainer">
                <div id="powerBarFill"></div>
                <div id="powerMarkings">
                    <!-- İşaret çizgileri JS tarafından eklenecek -->
                </div>
                
                <!-- İsteka Handle -->
                <div id="cueHandle">
                    <svg viewBox="0 0 10 400" fill="none" xmlns="http://www.w3.org/2000/svg" style="width: 8px; height: 100%;">
                        
                         <defs>
                            <!-- Koyu Ahşap (Butt) -->
                            <linearGradient id="buttGradient" x1="5" y1="250" x2="5" y2="400" gradientUnits="userSpaceOnUse">
                                <stop stop-color="#8B4513" offset="0%"/>
                                <stop stop-color="#5C3317" offset="100%"/>
                            </linearGradient>
                            <!-- Açık Şaft -->
                            <linearGradient id="shaftGradient" x1="5" y1="0" x2="5" y2="250" gradientUnits="userSpaceOnUse">
                                <stop stop-color="#FCEABF" offset="0%"/>
                                <stop stop-color="#D4B889" offset="100%"/>
                            </linearGradient>
                        </defs>
                        
                        <!-- İsteka Kulp/Butt (Altta) -->
                        <rect x="0" y="250" width="10" height="150" rx="5" fill="url(#buttGradient)"/> 
                        
                        <!-- İsteka Şaftı (Ortada) -->
                        <rect x="1" y="0" width="8" height="250" fill="url(#shaftGradient)"/> 
    
                        <!-- İsteka Ucu/Tip (Beyaz/Kemik - En Üstte) -->
                        <circle cx="5" cy="2" r="2.5" fill="#F5F5DC"/> 
                    </svg>
                </div>
            </div>
            
            <!-- English/Spin Selection Area (60x60) -->
            <div id="englishSelector">
                <canvas id="englishCanvas" width="60" height="60"></canvas>
            </div>
        </div>
        
    </div>

    <!-- Pause ve Retry Butonları Konteyneri -->
    <div id="gameControls" class="absolute top-4 right-4 flex space-x-3 z-50">
        <!-- Retry Button (Tekrar Dene) -->
        <button id="retryButton" class="js-button hidden game-control-button bg-red-600 hover:bg-red-700" data-action="retry_level">⟳</button>
        <!-- Pause Button (Duraklat) -->
        <button id="pauseButton" class="js-button hidden game-control-button hover:bg-gray-700" data-action="pause_menu">▐▐</button>
    </div>

    <!-- Main Menu / Screen Container -->
    <!-- Bu, masanın üstüne binen ve diğer menüleri gösteren katman -->
    <div id="screenContainer">
        <!-- Content will be injected here by JavaScript -->
    </div>
</div>

<script>
    // Sabitler 
    const CANVAS_WIDTH = 400;  
    const CANVAS_HEIGHT = 800; 
    const BALL_RADIUS = 20;    
    const CUSHION_WIDTH = 10; // Masa içindeki yeşil yastık kalınlığı
    const FRAME_PADDING = 20; // Ahşap çerçeve kalınlığı (CSS'deki #tableFrame padding'i)
    const FRICTION = 0.99; // Temel sürtünme
    const MIN_VELOCITY = 0.1; 
    
    // YENİ FİZİK SABİTLERİ
    const MAX_SHOT_POWER = 35; // VURUŞ GÜCÜ ARTTIRILDI (Toplar daha hızlı)
    const SPIN_CUSHION_EFFECT = 0.5; // Yastık çarpışmasında falso açı kayması çarpanı (Yüksek etki)
    const SPIN_ROLL_EFFECT = 0.003; // Masada yuvarlanma sırasında falso kayması için çarpan (Çok küçük)
    const POWER_DRAG_SENSITIVITY = 500; 
    
    const MAX_VISUAL_PULLBACK = 70; 
    
    const CUE_BALL_COLOR = '#FFFFFF';
    const OBJECT_BALL_COLOR = '#FF0000'; 
    const OBJECT_BALL_2_COLOR = '#FFFF00'; 
    const TEXT_COLOR = '#E5E7EB';

    const AIM_LINE_DOT_GAP = 7; 
    
    // Güç Barı İşaretlemesi
    const NUMBER_OF_MARKINGS = 16; 
    
    // Yan kontrol çubuğunun genişliği (CSS'deki .game-controls-container ile aynı olmalı)
    const SIDE_CONTROL_WIDTH = 80;

    // --- OYUN VERİLERİ (LEVELS ve SHOPITEMS) ---
    
    // Level Konumları (Beyaz, Kırmızı, Sarı)
    const levels = [
        // Level 1: Basic setup for 3-cushion (Easy)
        {
            name: "Giriş Vuruşu",
            white: { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT * 0.8 },
            red: { x: CANVAS_WIDTH * 0.3, y: CANVAS_HEIGHT * 0.25 },
            yellow: { x: CANVAS_WIDTH * 0.7, y: CANVAS_HEIGHT * 0.45 }
        },
        // Level 2: Slightly more challenging
        {
            name: "Köşe Atışı",
            white: { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT * 0.75 },
            red: { x: CANVAS_WIDTH * 0.25, y: CANVAS_HEIGHT * 0.35 },
            yellow: { x: CANVAS_WIDTH * 0.6, y: CANVAS_HEIGHT * 0.15 }
        },
        // Level 3: Corner shot focus
        {
            name: "Uzun Köşe",
            white: { x: CANVAS_WIDTH * 0.7, y: CANVAS_HEIGHT * 0.6 },
            red: { x: CANVAS_WIDTH * 0.8, y: CANVAS_HEIGHT * 0.15 },
            yellow: { x: CANVAS_WIDTH * 0.2, y: CANVAS_HEIGHT * 0.2 }
        }
    ];

    const shopItems = {
        cues: [
            { name: "Standard Cue", powerMultiplier: 1.0, price: 0, description: "Standart isteka. Güçlü ve güvenilir." },
            { name: "Power Max Cue", powerMultiplier: 1.5, price: 1000, description: "Daha sert vuruşlar için ekstra güç." },
            { name: "Control Pro Cue", powerMultiplier: 1.1, price: 2500, description: "Hafif güç artışı, falsoda daha iyi kontrol." }
        ],
        balls: [
            { name: "Default", color: CUE_BALL_COLOR, price: 0, description: "Standart beyaz top." },
            { name: "Blue Marble", color: '#00BFFF', price: 500, description: "Mavi mermer efektli beyaz top." },
            { name: "Gold Dust", color: '#FFD700', price: 1500, description: "Altın tozu desenli lüks top." }
        ]
    };

    // Oyun Durum Değişkenleri
    let currentScreen = 'main_menu';
    let gameReady = false;
    let canvas, ctx;
    let englishCanvas, englishCtx;
    let powerBarContainer, cueHandle, powerBarFill, powerMarkings; 
    let screenContainer, gameArea; // Yeni referans
    let tableFrame; 
    let retryButton, pauseButton; 
    let balls = [];
    let level = 1;
    let shotAttempt = 1;

    let isAiming = false; 
    let isDragging = false; 
    let aimTargetPos = { x: 0, y: 0 }; 
    let shotAngle = 0; 
    let shotPower = 0; 
    
    // GÜÇ ÇUBUĞU VE HAREKET DEĞİŞKENLERİ
    let isSliderDragging = false; 
    let dragStartScreenY = 0; 
    let cueHandleVisualY = 0; 
    
    // FALSO DEĞERLERİ (-1.0 ile 1.0 arası)
    let englishX = 0; // Yanal Falso (Sol: -1, Sağ: 1)
    let englishY = 0; // İleri/Geri Falso (Geri/Draw: -1, İleri/Follow: 1)
    
    let isBallMoving = false;
    let hitTargets = { red: false, yellow: false, bands: 0 };
    let currentCue = { name: "Standard Cue", powerMultiplier: 1.0, price: 0 };
    
    const CUE_CONTAINER_PADDING = 10; 

    // Player Data (Managed by localStorage)
    let playerData = {
        coins: 0,
        currentLevel: 1, // En yüksek geçilen level
        ownedCues: ["Standard Cue"],
        ownedBalls: ["Default"],
        selectedCue: "Standard Cue",
        selectedBall: "Default",
        sfx: true,
        music: true
    };

    const getUserId = () => 'local_user';

    // --- Persistence Functions (localStorage) ---

    function loadGameData() {
        const data = localStorage.getItem(`billiards_data_${getUserId()}`);
        if (data) {
            playerData = JSON.parse(data);
            level = playerData.currentLevel;
            currentCue = shopItems.cues.find(c => c.name === playerData.selectedCue) || shopItems.cues[0];
        }
        if (!playerData.ownedCues.includes("Standard Cue")) playerData.ownedCues.push("Standard Cue");
        if (!playerData.ownedBalls.includes("Default")) playerData.ownedBalls.push("Default");
        
        // Ensure currentLevel is at least 1
        if (playerData.currentLevel < 1) playerData.currentLevel = 1;
    }

    function saveGameData() {
        localStorage.setItem(`billiards_data_${getUserId()}`, JSON.stringify(playerData));
    }

    // --- Ball Class (Top Sınıfı) ---
    class Ball {
        constructor(x, y, color, type) {
            this.x = x;
            this.y = y;
            this.vx = 0;
            this.vy = 0;
            this.radius = BALL_RADIUS;
            this.color = color;
            this.type = type; // 'cue', 'red', 'yellow'
            this.mass = 1;
        }

        update() {
            if (this.isMoving()) {
                
                // 1. Hızın Güncellenmesi (Sürtünme ve Falso Etkisi dahil)
                let currentFriction = FRICTION;
                
                if (this.type === 'cue') {
                    const angle = Math.atan2(this.vy, this.vx);
                    const speed = Math.hypot(this.vx, this.vy);
                    
                    // --- Falso İvmesi (Yanal Kayma - EnglishX) ---
                    // englishX > 0 ise sağa doğru (hız vektörüne göre) kayma sağlar.
                    const ax_spin = Math.sin(angle) * englishX * SPIN_ROLL_EFFECT * speed;
                    const ay_spin = -Math.cos(angle) * englishX * SPIN_ROLL_EFFECT * speed;
                    
                    this.vx += ax_spin;
                    this.vy += ay_spin;
                    
                    // --- Draw/Follow Sürtünme Ayarlaması (EnglishY) ---
                    // englishY > 0 (Follow) -> Daha az sürtünme (daha yavaş yavaşlar)
                    // englishY < 0 (Draw) -> Daha fazla sürtünme (daha hızlı yavaşlar)
                    const spinFrictionAdjustment = englishY * 0.0008; 
                    currentFriction += spinFrictionAdjustment; 
                    // Sürtünmeyi makul bir aralıkta tut
                    currentFriction = Math.min(Math.max(0.98, currentFriction), 1); 
                }
                
                // Normal Sürtünmeyi Uygula
                this.vx *= currentFriction;
                this.vy *= currentFriction;

                // 2. Konum Güncelleme
                this.x += this.vx;
                this.y += this.vy;

                if (Math.hypot(this.vx, this.vy) < MIN_VELOCITY) {
                    this.vx = 0;
                    this.vy = 0;
                }

                this.checkCushionCollision();
            }
        }

        isMoving() {
            return this.vx !== 0 || this.vy !== 0;
        }

        checkCushionCollision() {
            let hit = false;
            let hitType = null; // 'horizontal' or 'vertical'
            
            // Yastık (Bant) Çarpışma Kontrolü
            if (this.x - this.radius < CUSHION_WIDTH) { 
                this.x = CUSHION_WIDTH + this.radius; 
                this.vx *= -1; 
                hit = true; 
                hitType = 'vertical';
            }
            if (this.x + this.radius > CANVAS_WIDTH - CUSHION_WIDTH) { 
                this.x = CANVAS_WIDTH - CUSHION_WIDTH - this.radius; 
                this.vx *= -1; 
                hit = true; 
                hitType = 'vertical';
            }
            if (this.y - this.radius < CUSHION_WIDTH) { 
                this.y = CUSHION_WIDTH + this.radius; 
                this.vy *= -1; 
                hit = true; 
                hitType = 'horizontal';
            }
            if (this.y + this.radius > CANVAS_HEIGHT - CUSHION_WIDTH) { 
                this.y = CANVAS_HEIGHT - CUSHION_WIDTH - this.radius; 
                this.vy *= -1; 
                hit = true; 
                hitType = 'horizontal';
            }

            if (hit && this.type === 'cue') {
                hitTargets.bands++;
                
                // --- Falso (English) Bant Etkisi ---
                // Falso, çarpışma sonrası hıza dik yönde bir ivme ekler.
                const speed = Math.hypot(this.vx, this.vy);
                
                if (hitType === 'vertical') {
                    // Dikey bantta, falso yanal olarak (y yönünde) kayma yaratır.
                    // englishX > 0 ise, hız vektörüne pozitif y yönünde bir kayma eklenir.
                    this.vy += englishX * SPIN_CUSHION_EFFECT; 
                } else if (hitType === 'horizontal') {
                    // Yatay bantta, falso yanal olarak (x yönünde) kayma yaratır.
                    // englishX > 0 ise, hız vektörüne pozitif x yönünde bir kayma eklenir.
                    this.vx += englishX * SPIN_CUSHION_EFFECT;
                }
                
                // Draw/Follow (englishY) Etkisi: Hızı koruma/azaltma
                // Bu etkiyi Draw/Follow sürtünme ayarlaması Ball.update'de zaten ele aldı.
            }
        }
        
        // 2.5D Top Tasarımı
        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

            let drawColor = this.color;
            if (this.type === 'cue') {
                const customBall = shopItems.balls.find(b => b.name === playerData.selectedBall);
                if (customBall) {
                    drawColor = customBall.color;
                }
            }
            
            // 2.5D Gölge ve Işık Efekti (Radial Gradient)
            const gradient = ctx.createRadialGradient(
                this.x - this.radius * 0.4, 
                this.y - this.radius * 0.4,
                1,
                this.x,
                this.y,
                this.radius
            );
            
            let shadowColor = '#333333';
            if (drawColor === '#FF0000') shadowColor = '#990000';
            if (drawColor === '#FFFF00') shadowColor = '#999900';
            
            gradient.addColorStop(0, '#ffffff'); // Işık Vurgusu
            gradient.addColorStop(0.5, drawColor);
            gradient.addColorStop(1, shadowColor); // Gölge Kenarı

            ctx.fillStyle = gradient;
            ctx.fill();
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2; 
            ctx.stroke();

            // English (Falso) noktası çiz
            if (this.type === 'cue') {
                ctx.beginPath();
                // Falso noktası, topun merkezinden englishX/englishY değerine göre kaydırılır.
                ctx.arc(this.x + englishX * 8, this.y + englishY * 8, 3, 0, Math.PI * 2); 
                ctx.fillStyle = '#111';
                ctx.fill();
            }
        }
    }


    // --- Oyun Mantığı ve Çekirdek Fonksiyonlar ---

    function initializeGame() {
        canvas = document.getElementById('billiardsCanvas');
        ctx = canvas.getContext('2d');
        englishCanvas = document.getElementById('englishCanvas');
        englishCtx = englishCanvas.getContext('2d');
        powerBarContainer = document.getElementById('powerBarContainer');
        cueHandle = document.getElementById('cueHandle');
        powerBarFill = document.getElementById('powerBarFill');
        powerMarkings = document.getElementById('powerMarkings');
        screenContainer = document.getElementById('screenContainer');
        gameArea = document.getElementById('gameArea'); // Yeni referans
        tableFrame = document.getElementById('tableFrame'); 
        
        retryButton = document.getElementById('retryButton');
        pauseButton = document.getElementById('pauseButton');


        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;
        
        // İşaret çizgilerini oluştur
        for(let i = 0; i < NUMBER_OF_MARKINGS; i++) {
            const marking = document.createElement('div');
            marking.className = 'marking-line';
            powerMarkings.appendChild(marking);
        }

        updateCueHandleVisuals(); 

        const updateCanvasSize = () => {
            const container = document.getElementById('gameContainer');
            const ratio = CANVAS_WIDTH / CANVAS_HEIGHT; 
            const sideControlWidth = SIDE_CONTROL_WIDTH + 20; // Kontrol çubuğu genişliği + minimum boşluk (px)

            let availableWidth = container.clientWidth - sideControlWidth;
            let availableHeight = container.clientHeight - 20; // Üst/alt boşluk için 20px

            let newWidth, newHeight;

            // Masa boyutunu, kontrol barı da dahil olmak üzere alana sığacak şekilde hesapla
            if (availableWidth / availableHeight > ratio) {
                // Yükseklik kısıtlı
                newHeight = availableHeight;
                newWidth = newHeight * ratio;
            } else {
                // Genişlik kısıtlı
                newWidth = availableWidth;
                newHeight = newWidth / ratio;
            }
            
            // Masa çerçevesinin nihai boyutları
            const tableFrameWidth = newWidth + 2 * FRAME_PADDING;
            const tableFrameHeight = newHeight + 2 * FRAME_PADDING;
            
            // Ahşap çerçevenin boyutunu ayarla
            tableFrame.style.width = `${tableFrameWidth}px`;
            tableFrame.style.height = `${tableFrameHeight}px`;

            // Canvas'ın boyutunu çerçevenin içine sığacak şekilde ayarla
            canvas.style.width = `${newWidth}px`;
            canvas.style.height = `${newHeight}px`;
            
            // Kontrol çubuğu yüksekliğini masanın yüksekliğine göre ayarla
            const powerBar = document.getElementById('powerBarContainer');
            // Masanın yüksekliğinin yarısından biraz azını kullan
            powerBar.style.height = `${Math.min(newHeight * 0.5, 400)}px`; 
        };

        window.addEventListener('resize', updateCanvasSize);
        updateCanvasSize(); 

        loadGameData();

        // Giriş dinleyicileri (Canvas)
        canvas.addEventListener('mousedown', handlePointerDown);
        canvas.addEventListener('mousemove', handlePointerMove);
        canvas.addEventListener('mouseup', handlePointerUp);
        canvas.addEventListener('touchstart', handlePointerDown);
        canvas.addEventListener('touchmove', handlePointerMove);
        canvas.addEventListener('touchend', handlePointerUp);

        // Giriş dinleyicileri (Falso - English Canvas)
        englishCanvas.addEventListener('mousedown', handleEnglishDown);
        englishCanvas.addEventListener('mousemove', handleEnglishMove);
        englishCanvas.addEventListener('mouseup', handleEnglishUp);
        englishCanvas.addEventListener('touchstart', handleEnglishDown);
        englishCanvas.addEventListener('touchmove', handleEnglishMove);
        englishCanvas.addEventListener('touchend', handleEnglishUp);
        
        // Giriş dinleyicileri (Güç - Document'e bağlı)
        powerBarContainer.addEventListener('mousedown', handleCueSliderDown);
        powerBarContainer.addEventListener('touchstart', handleCueSliderDown);
        
        document.addEventListener('mousemove', handleCueSliderMove);
        document.addEventListener('mouseup', handleCueSliderUp);
        document.addEventListener('touchmove', handleCueSliderMove);
        document.addEventListener('touchend', handleCueSliderUp);

        // Yeni buton olayları
        document.getElementById('pauseButton').addEventListener('click', () => handleMenuAction('pause_menu'));
        document.getElementById('retryButton').addEventListener('click', () => handleMenuAction('retry_level'));

        gameReady = true;
        showScreen('main_menu');
        gameLoop();
    }

    function loadLevel(lvl) {
        if (lvl > levels.length) {
            showScreen('game_end'); 
            return;
        }

        const currentLevelData = levels[lvl - 1];
        level = lvl;
        shotAttempt = 1;
        isBallMoving = false;
        isAiming = true; 
        shotPower = 0;
        
        // Ekran gösterimini showScreen() yönetiyor.
        // updateCanvasSize() tekrar çağrılırsa kontrol barı yüksekliği güncellenir.
        
        balls = [];
        const cueBallData = currentLevelData.white;
        balls.push(new Ball(cueBallData.x, cueBallData.y, CUE_BALL_COLOR, 'cue'));
        balls.push(new Ball(currentLevelData.red.x, currentLevelData.red.y, OBJECT_BALL_COLOR, 'red'));
        balls.push(new Ball(currentLevelData.yellow.x, currentLevelData.yellow.y, OBJECT_BALL_2_COLOR, 'yellow'));
        
        aimTargetPos = { x: cueBallData.x, y: cueBallData.y - 100 }; 
        resetShotTargets();
        updateCueHandleVisuals(); 
    }

    function resetShotTargets() {
         hitTargets = { red: false, yellow: false, bands: 0 };
    }

    function gameLoop() {
        if (gameReady) {
            update();
            draw();
            checkGameState();
            
            if (!isBallMoving && currentScreen === 'game') {
                isAiming = true;
                // Kontrolleri göster
                document.getElementById('englishSelector').style.display = 'block';
                document.getElementById('powerBarContainer').style.display = 'block';
            } else {
                 isAiming = false;
            }
        }
        requestAnimationFrame(gameLoop);
    }

    function update() {
        if (currentScreen !== 'game') return;

        let allStopped = true;
        balls.forEach(ball => {
            ball.update();
            if (ball.isMoving()) {
                allStopped = false;
            }
        });

        isBallMoving = !allStopped;
        
        if (isBallMoving) {
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    checkBallCollision(balls[i], balls[j]);
                }
            }
        }
    }

    function checkGameState() {
        if (currentScreen !== 'game') return;

        if (!isBallMoving && !isAiming) {
            
            if (hitTargets.red && hitTargets.yellow && hitTargets.bands >= 3) {
                // KAZANÇ: currentLevel'ı bir sonraki levela ilerlet
                playerData.currentLevel = Math.max(playerData.currentLevel, level + 1);
                saveGameData();
                showScreen('level_complete');
            } else {
                // KAYIP/FAUL
                loadLevel(level); // Level'ı yeniden başlat
            }
            
            resetShotTargets();
            shotPower = 0;
        } 
    }

    function checkBallCollision(b1, b2) {
        const dx = b2.x - b1.x;
        const dy = b2.y - b1.y;
        const distSq = dx * dx + dy * dy;
        const minDist = b1.radius + b2.radius;

        if (distSq <= minDist * minDist) {
            const dist = Math.sqrt(distSq);
            const nx = dx / dist; 
            const ny = dy / dist; 

            const overlap = minDist - dist;
            b1.x -= overlap * 0.5 * nx;
            b1.y -= overlap * 0.5 * ny;
            b2.x += overlap * 0.5 * nx;
            b2.y += overlap * 0.5 * ny;

            const v1n = b1.vx * nx + b1.vy * ny;
            const v2n = b2.vx * nx + b2.vy * ny;

            if (v1n > 0 || v2n < 0) {
                 const newV1n = v2n;
                 const newV2n = v1n;

                 b1.vx += (newV1n - v1n) * nx;
                 b1.vy += (newV1n - v1n) * ny;
                 b2.vx += (newV2n - v2n) * nx;
                 b2.vy += (newV2n - v2n) * ny;

                if (b1.type === 'cue' || b2.type === 'cue') {
                    const otherBall = b1.type === 'cue' ? b2 : b1;
                    if (otherBall.type === 'red') hitTargets.red = true;
                    if (otherBall.type === 'yellow') hitTargets.yellow = true;
                }
            }
        }
    }

    function draw() {
        // Tuvali Temizle
        // Kumaş rengi CSS tarafından ayarlandığı için burada burada sadece bantları çiziyoruz
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Yastıkları Çiz
        ctx.fillStyle = '#056238'; // Koyu yeşil bant rengi
        // Üst ve Alt Yastıklar
        ctx.fillRect(0, 0, CANVAS_WIDTH, CUSHION_WIDTH); 
        ctx.fillRect(0, CANVAS_HEIGHT - CUSHION_WIDTH, CANVAS_WIDTH, CUSHION_WIDTH); 
        // Sol ve Sağ Yastıklar (köşeleri örtmemek için başlangıç/bitiş noktasını ayarla)
        ctx.fillRect(0, CUSHION_WIDTH, CUSHION_WIDTH, CANVAS_HEIGHT - 2 * CUSHION_WIDTH); 
        ctx.fillRect(CANVAS_WIDTH - CUSHION_WIDTH, CUSHION_WIDTH, CUSHION_WIDTH, CANVAS_HEIGHT - 2 * CUSHION_WIDTH); 

        // Bantlara gölge ve ışık efekti ver (Görseli daha iyi hale getirmek için)
        // İç gölge
        ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
        ctx.shadowBlur = 10;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        
        // Gölgeleri çizmek için sadece masanın içini tekrar çiz
        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'; 
        ctx.fillRect(CUSHION_WIDTH, CUSHION_WIDTH, CANVAS_WIDTH - 2*CUSHION_WIDTH, CANVAS_HEIGHT - 2*CUSHION_WIDTH);
        
        // Gölgeyi sıfırla
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;


        // Topları çiz
        balls.forEach(ball => ball.draw());

        // Nişan alma çizimlerini yap
        if (isAiming) {
            drawAiming();
        }

        // Seviye metni çiz (topların üstünde)
        ctx.fillStyle = TEXT_COLOR;
        ctx.font = 'bold 24px Inter';
        ctx.textAlign = 'left';
        ctx.fillText(`Level: ${level}`, 20, 40); 

        // English Seçici UI çiz
        drawEnglishSelector();
    }
    
    // Nişan Çizgisi Top Çarpışması Hassasiyeti ve Noktalı Çizgi
    function drawAiming() {
        const cueBall = balls[0];
        const currentAngle = Math.atan2(aimTargetPos.y - cueBall.y, aimTargetPos.x - cueBall.x);
        
        // --- 1. Çarpışma Noktasını Hesapla (Top veya Bant) ---
        
        let minHitDistance = Infinity; // Beyaz topun merkezinden çarpışma noktasına olan mesafe

        // Bant çarpışması
        const dx = Math.cos(currentAngle);
        const dy = Math.sin(currentAngle);
        
        // Yatay Bantlar (Üst ve Alt)
        if (dy !== 0) {
            const y1 = CUSHION_WIDTH + BALL_RADIUS;
            const y2 = CANVAS_HEIGHT - CUSHION_WIDTH - BALL_RADIUS;

            [y1, y2].forEach(y_cushion => {
                if ((dy > 0 && y_cushion > cueBall.y) || (dy < 0 && y_cushion < cueBall.y)) {
                    const distY = (y_cushion - cueBall.y) / dy;
                    const hitX = cueBall.x + dx * distY;
                    
                    if (hitX >= CUSHION_WIDTH + BALL_RADIUS && hitX <= CANVAS_WIDTH - CUSHION_WIDTH - BALL_RADIUS && distY > BALL_RADIUS) {
                        minHitDistance = Math.min(minHitDistance, distY);
                    }
                }
            });
        }
        
        // Dikey Bantlar (Sol ve Sağ)
        if (dx !== 0) {
            const x1 = CUSHION_WIDTH + BALL_RADIUS;
            const x2 = CANVAS_WIDTH - CUSHION_WIDTH - BALL_RADIUS;

            [x1, x2].forEach(x_cushion => {
                 if ((dx > 0 && x_cushion > cueBall.x) || (dx < 0 && x_cushion < cueBall.x)) {
                    const distX = (x_cushion - cueBall.x) / dx;
                    const hitY = cueBall.y + dy * distX;
                    
                    if (hitY >= CUSHION_WIDTH + BALL_RADIUS && hitY <= CANVAS_HEIGHT - CUSHION_WIDTH - BALL_RADIUS && distX > BALL_RADIUS) {
                         minHitDistance = Math.min(minHitDistance, distX);
                    }
                 }
            });
        }

        // Top çarpışması
        for (let i = 1; i < balls.length; i++) {
            const targetBall = balls[i];
            const distVectorX = targetBall.x - cueBall.x;
            const distVectorY = targetBall.y - cueBall.y;

            // Beyaz top merkezinden hedef top merkezine olan vektörün, atış çizgisi üzerindeki izdüşümü
            const projection = distVectorX * dx + distVectorY * dy;

            if (projection > BALL_RADIUS) { // Hedef top beyaz topun önünde mi?
                const distCenterSq = distVectorX * distVectorX + distVectorY * distVectorY;
                const radiusSumSq = (BALL_RADIUS * 2) * (BALL_RADIUS * 2);
                
                const perpendicularDistSq = distCenterSq - projection * projection;
                
                if (perpendicularDistSq < radiusSumSq) { // Çarpışma yolu üzerinde mi?
                    const tangentDist = Math.sqrt(radiusSumSq - perpendicularDistSq);
                    const hitDistance = projection - tangentDist;
                    
                    if (hitDistance > BALL_RADIUS) { // Kendi topumuzun kenarından sonra mı?
                        minHitDistance = Math.min(minHitDistance, hitDistance);
                    }
                }
            }
        }
        
        // Beyaz top merkezinden atışın biteceği nokta
        const stopDistance = minHitDistance === Infinity ? CANVAS_WIDTH * 2 : minHitDistance;
        
        // const hitPointX = cueBall.x + Math.cos(currentAngle) * stopDistance;
        // const hitPointY = cueBall.y + Math.sin(currentAngle) * stopDistance;

        // --- Noktalı Nişan Çizgisi ---
        
        ctx.strokeStyle = '#FFF'; 
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.8;

        const startDrawDistance = BALL_RADIUS; // Çizime beyaz topun kenarından başla
        const dotGap = AIM_LINE_DOT_GAP; 
        const dotLength = dotGap * 0.8; // Nokta uzunluğu, boşluktan biraz kısa

        for (let d = startDrawDistance; d < stopDistance; d += dotGap) {
            
            const startX = cueBall.x + Math.cos(currentAngle) * d;
            const startY = cueBall.y + Math.sin(currentAngle) * d;
            
            let endDistance = d + dotLength;
            // Çizgi bitmeden önce son nokta uzunluğunu ayarla
            if (endDistance > stopDistance) {
                endDistance = stopDistance;
            }

            const endX = cueBall.x + Math.cos(currentAngle) * endDistance;
            const endY = cueBall.y + Math.sin(currentAngle) * endDistance;

            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            
            if (endDistance === stopDistance) break;
        }

        ctx.globalAlpha = 1.0;

        // İsteka çubuğu görsel geri bildirimi (çekildiğinde)
        if (shotPower > 0.1) {
            const cueLength = 100;
            const cueTipGap = BALL_RADIUS + 5; 
            
            // Güce göre geri çekilme mesafesi
            const powerRatio = shotPower / MAX_SHOT_POWER;
            const pullBackDist = powerRatio * 50; 

            // İsteka, atış açısının tam tersi yönüne yerleştirilir
            const cueStartDist = cueTipGap + pullBackDist; 
            const cueEndDist = cueStartDist + cueLength;

            const cueStartX = cueBall.x - Math.cos(currentAngle) * cueStartDist;
            const cueStartY = cueBall.y - Math.sin(currentAngle) * cueStartDist;
            const cueEndX = cueBall.x - Math.cos(currentAngle) * cueEndDist;
            const cueEndY = cueBall.y - Math.sin(currentAngle) * cueEndDist;

            ctx.strokeStyle = '#8B4513'; 
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(cueStartX, cueStartY);
            ctx.lineTo(cueEndX, cueEndY);
            ctx.stroke();
        }
    }

    function drawEnglishSelector() {
        // English (Falso) Seçiciyi Çiz
        const size = englishCanvas.width;
        const center = size / 2;

        englishCtx.clearRect(0, 0, size, size);
        englishCtx.beginPath();
        englishCtx.arc(center, center, center - 2, 0, Math.PI * 2);
        englishCtx.fillStyle = CUE_BALL_COLOR;
        englishCtx.strokeStyle = '#aaa';
        englishCtx.lineWidth = 2;
        englishCtx.fill();
        englishCtx.stroke();

        const markerX = center + englishX * (center - 5);
        const markerY = center + englishY * (center - 5);

        englishCtx.beginPath();
        englishCtx.arc(markerX, markerY, 4, 0, Math.PI * 2); 
        englishCtx.fillStyle = '#111';
        englishCtx.fill();
    }


    // --- Giriş İşleyicileri (Nişan Açısı - Canvas) ---

    function getRelativeCoordinates(e, element) {
        const rect = element.getBoundingClientRect();
        const clientX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
        const clientY = e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
        const x = clientX - rect.left;
        const y = clientY - rect.top;
        
        if (element.id === 'billiardsCanvas') {
            const scaleX = CANVAS_WIDTH / rect.width;
            const scaleY = CANVAS_HEIGHT / rect.height;
            return { x: x * scaleX, y: y * scaleY };
        }
        return { x: x, y: y };
    }

    function handlePointerDown(e) {
        e.preventDefault();
        if (currentScreen !== 'game' || isBallMoving || !isAiming) return;

        if (e.target === canvas || e.target.id === 'billiardsCanvas') {
            isDragging = true;
            aimTargetPos = getRelativeCoordinates(e, canvas);
        }
    }

    function handlePointerMove(e) {
        e.preventDefault();
        if (currentScreen !== 'game' || isBallMoving || !isAiming || !isDragging) return;

        aimTargetPos = getRelativeCoordinates(e, canvas);
    }

    function handlePointerUp(e) {
        e.preventDefault();
        if (currentScreen !== 'game' || isBallMoving || !isAiming) return;
        
        isDragging = false;
    }
    
    // --- GÜÇ ÇUBUĞU HAREKET ---

    function updateCueHandleVisuals() {
        const powerRatio = shotPower / MAX_SHOT_POWER; 
        const visualDistance = powerRatio * MAX_VISUAL_PULLBACK;
        
        // İsteka görselini POZİTİF YÖNDE (aşağı) hareket ettir.
        cueHandle.style.transform = `translateY(${visualDistance}px)`; 
        
        updatePowerBar(shotPower);
    }

    function handleCueSliderDown(e) {
        e.preventDefault();
        if (currentScreen !== 'game' || isBallMoving || !isAiming) return;
        
        if (e.target.closest('#powerBarContainer')) {
            isSliderDragging = true;
            
            const clientY = e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
            
            dragStartScreenY = clientY; 
            cueHandleVisualY = 0; 
            shotPower = 0; 
            updateCueHandleVisuals(); 
        }
    }
    
    function handleCueSliderMove(e) {
        if (!isSliderDragging || !isAiming) return;
        e.preventDefault();

        const clientY = e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : dragStartScreenY);
        
        const deltaY = clientY - dragStartScreenY; 
        
        // Güç çekme mesafesi (sadece aşağı çekmeyi say)
        const powerDrag = Math.min(Math.max(0, deltaY), POWER_DRAG_SENSITIVITY);

        // Güç Oranı (0.0 ile 1.0 arası)
        const powerRatio = powerDrag / POWER_DRAG_SENSITIVITY;
        
        shotPower = powerRatio * MAX_SHOT_POWER;

        updateCueHandleVisuals(); 
    }

    function handleCueSliderUp(e) {
        if (!isSliderDragging || !isAiming) return;
        isSliderDragging = false;
        
        cueHandleVisualY = 0;
        
        if (shotPower > 0.5) { 
            isAiming = false;
            // Kontrolleri gizle
            document.getElementById('powerBarContainer').style.display = 'none';
            document.getElementById('englishSelector').style.display = 'none';
            executeShot();
        } else {
            shotPower = 0; 
        }
        updateCueHandleVisuals(); 
    }


    // English Selector Handlers (Falso Seçici İşleyicileri)
    let isEnglishDragging = false;
    function handleEnglishDown(e) {
        e.preventDefault();
        if (currentScreen !== 'game' || isBallMoving || !isAiming) return; 
        isEnglishDragging = true;
        handleEnglishMove(e);
    }
    
    function handleEnglishMove(e) {
        e.preventDefault();
        if (currentScreen !== 'game' || !isEnglishDragging) return;
        
        const rect = englishCanvas.getBoundingClientRect();
        const clientX = e.clientX || e.touches[0].clientX;
        const clientY = e.clientY || e.touches[0].clientY;

        const x = clientX - rect.left - rect.width / 2;
        const y = clientY - rect.top - rect.height / 2;
        const maxDist = rect.width / 2 - 5;
        const dist = Math.hypot(x, y);

        if (dist <= maxDist) {
            englishX = x / maxDist; 
            englishY = y / maxDist;
        } else {
            // Sınırın dışına çıkarsa, en yakındaki sınır noktasını al
            englishX = x / dist;
            englishY = y / dist;
        }
        drawEnglishSelector();
    }
    
    function handleEnglishUp(e) {
        e.preventDefault();
        isEnglishDragging = false;
    }


    function updatePowerBar(power) {
        const powerLevel = Math.min(power / MAX_SHOT_POWER, 1);
        
        // Güç dolumunu yansıtan rengi ayarla
        if (powerLevel < 0.33) {
            powerBarFill.style.backgroundColor = '#22c55e'; // Yeşil
        } else if (powerLevel < 0.66) {
            powerBarFill.style.backgroundColor = '#facc15'; // Sarı
        } else {
            powerBarFill.style.backgroundColor = '#ef4444'; // Kırmızı
        }
        
        // Güç dolumunu görünür kılmak için altındaki koyu rengi kullan
        powerBarFill.style.opacity = '0.5'; // Yarı şeffaf dolum
        powerBarFill.style.height = `${powerLevel * 100}%`;
    }

    function executeShot() {
        const cueBall = balls[0];

        shotAngle = Math.atan2(aimTargetPos.y - cueBall.y, aimTargetPos.x - cueBall.x);

        const totalPower = shotPower * currentCue.powerMultiplier;

        cueBall.vx = Math.cos(shotAngle) * totalPower;
        cueBall.vy = Math.sin(shotAngle) * totalPower;

        isBallMoving = true;
        shotAttempt++;
    }

    // --- UI/Screen Management (Ekran Yönetimi) ---

    function showScreen(screenId) {
        
        // Animasyon Başlangıcı: Önce içeriği gizle, opacity'i 0 yap
        if (screenId !== currentScreen && screenId !== 'game') {
            screenContainer.style.opacity = '0';
            screenContainer.style.pointerEvents = 'none';
        }

        currentScreen = screenId;
        
        // Tüm kontrol butonlarını gizle
        retryButton.classList.add('hidden');
        pauseButton.classList.add('hidden');
        document.getElementById('englishSelector').style.display = 'none';
        document.getElementById('powerBarContainer').style.display = 'none';

        if (screenId !== 'game') {
            // Menü ekranı aktif: Oyun alanını gizle, menü konteynerini göster
            gameArea.style.display = 'none'; 
            screenContainer.style.display = 'flex';
            screenContainer.style.pointerEvents = 'auto';
            
            // Ana menü, ayarlar ve mağaza için arkaplan karartmayı kaldır
            if (['main_menu', 'options', 'shop', 'level_select'].includes(screenId)) {
                screenContainer.style.backgroundColor = 'transparent';
            } else {
                screenContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.7)'; // Pause ve Tamamlandı için
            }

            setTimeout(() => { // Animasyonun uygulanması için kısa bir gecikme
                screenContainer.style.opacity = '1';
            }, 50);
        } else {
            // Oyun ekranı aktif: Oyun alanını göster, menü konteynerini gizle
            screenContainer.style.display = 'none';
            gameArea.style.display = 'flex'; 
            
            // Oyun sırasında butonları göster
            pauseButton.classList.remove('hidden');
            retryButton.classList.remove('hidden'); 
            
            // Eğer top duruyorsa ve nişan alınıyorsa kontrol barını göster
            if (!isBallMoving) {
                document.getElementById('englishSelector').style.display = 'block';
                document.getElementById('powerBarContainer').style.display = 'block';
            }
        }


        switch (screenId) {
            case 'main_menu':
                screenContainer.innerHTML = createMainMenu();
                break;
            case 'level_select':
                screenContainer.innerHTML = createLevelSelectScreen();
                break;
            case 'options':
                screenContainer.innerHTML = createOptionsScreen();
                break;
            case 'shop':
                screenContainer.innerHTML = createShopScreen();
                break;
            case 'game':
                // `loadLevel` çağrılırken ayarlandı, burada sadece görünürlük yönetilir.
                break;
            case 'pause_menu':
                screenContainer.innerHTML = createPauseMenu();
                break;
            case 'level_complete':
                screenContainer.innerHTML = createLevelCompleteScreen();
                break;
            case 'game_end':
                screenContainer.innerHTML = createGameEndScreen();
                break;
        }
        attachButtonListeners();
    }
    
    function attachButtonListeners() {
        document.querySelectorAll('.js-button').forEach(button => {
            // Kontrol butonlarına olay zaten initializeGame'de atanmıştır. 
            // Sadece menü butonlarına olay ataması yap
            if (button.id !== 'pauseButton' && button.id !== 'retryButton') {
                button.addEventListener('click', () => {
                    const action = button.getAttribute('data-action');
                    handleMenuAction(action, button);
                });
            }
        });
        
        // Shop item listener'ı, mağaza açıldığında attachShopListeners ile atanır.
    }

    function handleMenuAction(action, button = null) {
        switch (action) {
            case 'start':
                showScreen('level_select');
                break;
            case 'level_select':
                showScreen('level_select');
                break;
            case 'select_level':
                const lvl = parseInt(button.getAttribute('data-level'));
                if (lvl <= playerData.currentLevel) {
                    loadLevel(lvl);
                    showScreen('game');
                }
                break;
            case 'retry_level':
                loadLevel(level);
                showScreen('game');
                break;
            case 'options':
                showScreen('options');
                break;
            case 'shop':
                showScreen('shop');
                break;
            case 'continue':
                showScreen('game');
                break;
            case 'pause_menu':
                showScreen('pause_menu');
                break;
            case 'main_menu':
                showScreen('main_menu');
                break;
            case 'next_level':
                loadLevel(level + 1);
                showScreen('game');
                break;
            case 'toggle_sfx':
                playerData.sfx = !playerData.sfx;
                saveGameData();
                showScreen('options');
                break;
            case 'toggle_music':
                playerData.music = !playerData.music;
                saveGameData();
                showScreen('options');
                break;
        }
    }

    function drawBallHtml(color, x, y, size) {
        // Top görselini CSS ve gölgelerle çizmek için yardımcı fonksiyon
        return `
            <div style="
                position: absolute;
                bottom: ${y}px;
                left: ${x}px;
                width: ${size}px;
                height: ${size}px;
                border-radius: 50%;
                background: radial-gradient(circle at 35% 35%, #fff 0%, ${color} 40%, ${color} 70%, ${color} 100%);
                box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5), 0 5px 10px rgba(0, 0, 0, 0.6);
            "></div>
        `;
    }

    function createMainMenu() {
        // Tam ekran menü için 'menu-fullscreen' sınıfını kullan
        return `
            <div class="menu-content menu-fullscreen p-8 relative">
                <h1 class="text-6xl font-extrabold text-white mb-10" style="text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">3-CUSHION</h1>
                <div class="flex flex-col space-y-6 w-full items-center">
                    <button class="game-button js-button" data-action="level_select">OYNA</button>
                    <button class="game-button js-button" data-action="options">AYARLAR</button>
                    <button class="game-button js-button" data-action="shop">MAĞAZA</button>
                </div>
                
                <!-- Bilardo Topları Görseli (Görseldeki gibi alt sağa hizalı) -->
                <div style="position: absolute; bottom: 40px; right: 40px;">
                    <!-- Sarı Top -->
                    ${drawBallHtml('#FFFF00', 30, 20, 30)} 
                    <!-- Beyaz Top -->
                    ${drawBallHtml('#FFFFFF', 10, 30, 35)} 
                    <!-- Kırmızı Top -->
                    ${drawBallHtml('#FF0000', 0, 0, 40)} 
                </div>

            </div>
        `;
    }
    
    function createLevelSelectScreen() {
        // Level Seçimi, odaklanmış standart bir kutu olarak kalmalı.
        let levelHtml = `
            <div class="menu-content menu-standard p-6">
                <h1 class="text-3xl font-bold text-white mb-8">Level Seçimi</h1>
                <div class="grid grid-cols-2 sm:grid-cols-3 gap-4 w-full max-w-md mx-auto">
        `;

        levels.forEach((lvl, index) => {
            const currentLvl = index + 1;
            const isUnlocked = currentLvl <= playerData.currentLevel;
            const buttonColor = isUnlocked ? 'bg-indigo-600 hover:bg-indigo-700' : 'bg-gray-600 cursor-not-allowed';
            const buttonText = isUnlocked ? `LEVEL ${currentLvl}` : '🔒';
            
            levelHtml += `
                <button class="standard-button p-4 flex flex-col items-center justify-center ${buttonColor} ${isUnlocked ? 'js-button' : ''}" data-action="select_level" data-level="${currentLvl}" ${!isUnlocked ? 'disabled' : ''} style="height: 80px; width: 100%; max-width: none;">
                    <span class="text-2xl font-extrabold">${buttonText}</span>
                </button>
            `;
        });

        levelHtml += `
                </div>
                <!-- Tam ekran menülerdeki Geri butonu için game-button stili kullanıldı. -->
                <button class="game-button bg-gray-500 hover:bg-gray-600 mt-8 js-button" data-action="main_menu">Geri</button>
            </div>
        `;
        return levelHtml;
    }


    function createPauseMenu() {
        return `
            <div class="menu-content menu-standard p-8">
                <h1 class="text-3xl font-bold text-white mb-8">Oyun Duraklatıldı</h1>
                <div class="flex flex-col space-y-6 w-full max-w-sm">
                    <button class="game-button bg-green-500 hover:bg-green-600 js-button" data-action="continue">Devam Et</button>
                    <button class="standard-button js-button" data-action="options">Ayarlar</button>
                    <button class="standard-button js-button" data-action="main_menu">Ana Menü</button>
                </div>
            </div>
        `;
    }

    function calculateCoins() {
        const baseCoins = 100;
        let bonus = 0;
        if (shotAttempt === 1) bonus = 50;
        if (shotAttempt <= 3) bonus = 20;

        const earnedCoins = baseCoins + bonus;
        playerData.coins += earnedCoins;
        saveGameData();
        return earnedCoins;
    }

    function createLevelCompleteScreen() {
        const earned = calculateCoins();
        const nextLevelExists = level < levels.length;
        
        return `
            <div class="menu-content menu-standard p-8 bg-green-700 text-white">
                <h1 class="text-4xl font-extrabold mb-4">LEVEL TAMAMLANDI!</h1>
                <p class="text-lg mb-2">Deneme Sayısı: ${shotAttempt}</p>
                <p class="text-2xl font-bold mb-6">Kazanılan Para: <span class="text-yellow-300">${earned} 💰</span></p>
                <p class="text-lg mb-8">Toplam Para: ${playerData.coins} 💰</p>
                <div class="flex flex-col space-y-6 w-full max-w-sm">
                    ${nextLevelExists ? 
                        `<button class="game-button bg-green-900 hover:bg-green-800 js-button" data-action="next_level">Sonraki Level (Level ${level + 1})</button>` :
                        `<button class="game-button bg-yellow-500 text-gray-900 hover:bg-yellow-400 js-button" data-action="main_menu">Tüm Leveller Bitti!</button>`
                    }
                    <!-- Tam ekran menülerdeki Geri butonu için game-button stili kullanıldı. -->
                    <button class="game-button bg-gray-500 hover:bg-gray-600 js-button" data-action="main_menu">Ana Menü</button>
                </div>
            </div>
        `;
    }
    
    function createGameEndScreen() {
        return `
            <div class="menu-content menu-standard p-8 bg-yellow-500 text-gray-900">
                <h1 class="text-4xl font-extrabold mb-4">TEBRİKLER!</h1>
                <p class="text-xl mb-6">Tüm mevcut levelleri tamamladınız!</p>
                <p class="text-lg mb-8">Toplam Para: ${playerData.coins} 💰</p>
                <div class="flex flex-col space-y-6 w-full max-w-sm">
                    <button class="game-button bg-yellow-700 text-white hover:bg-yellow-600 js-button" data-action="shop">Mağazayı Ziyaret Et</button>
                    <!-- Tam ekran menülerdeki Geri butonu için game-button stili kullanıldı. -->
                    <button class="game-button bg-gray-700 text-white hover:bg-gray-800 js-button" data-action="main_menu">Ana Menü</button>
                </div>
            </div>
        `;
    }

    function createOptionsScreen() {
        const sfxText = playerData.sfx ? 'AÇIK' : 'KAPALI';
        const musicText = playerData.music ? 'AÇIK' : 'KAPALI';

        return `
            <div class="menu-content menu-fullscreen p-8">
                <div class="w-full max-w-xl mx-auto pt-10">
                    <h1 class="text-4xl font-extrabold text-white mb-10">Ayarlar</h1>
                    <div class="flex flex-col space-y-6 w-full max-w-md mx-auto">
                        <div class="flex justify-between items-center bg-gray-800 p-4 rounded-xl w-full shadow-lg">
                            <span class="text-white text-lg font-semibold">Ses Efektleri:</span>
                            <button class="standard-button text-sm px-6 py-3 w-auto ${playerData.sfx ? 'bg-green-600 hover:bg-green-700' : 'bg-red-600 hover:bg-red-700'} js-button" data-action="toggle_sfx">
                                ${sfxText}
                            </button>
                        </div>
                        <div class="flex justify-between items-center bg-gray-800 p-4 rounded-xl w-full shadow-lg">
                            <span class="text-white text-lg font-semibold">Müzik:</span>
                            <button class="standard-button text-sm px-6 py-3 w-auto ${playerData.music ? 'bg-green-600 hover:bg-green-700' : 'bg-red-600 hover:bg-red-700'} js-button" data-action="toggle_music">
                                ${musicText}
                            </button>
                        </div>
                        <!-- Tam ekran menülerdeki Geri butonu için game-button stili kullanıldı. -->
                        <button class="game-button bg-gray-500 hover:bg-gray-600 mt-10 js-button" data-action="main_menu">Geri</button>
                    </div>
                </div>
            </div>
        `;
    }

    function createShopScreen() {
        let shopHtml = `
            <div class="menu-content menu-fullscreen p-8 overflow-y-auto"> 
                <div class="w-full max-w-xl mx-auto pt-10 pb-20">
                    <h1 class="text-4xl font-extrabold mb-4">Mağaza</h1>
                    <p class="text-yellow-400 text-2xl mb-8 font-bold">Para: ${playerData.coins} 💰</p>
                    
                    <div class="w-full max-w-md mx-auto">
                        <h2 class="text-2xl font-semibold mt-4 mb-3 border-b border-gray-700 pb-1 text-left text-white">İstekalar (Güç)</h2>
        `;

        // Cues Section
        shopItems.cues.forEach(item => {
            const isOwned = playerData.ownedCues.includes(item.name);
            const isSelected = playerData.selectedCue === item.name;
            const canAfford = playerData.coins >= item.price;
            
            let buttonText, buttonColor, disabled = '';

            if (isOwned) {
                buttonText = isSelected ? 'KULLANILIYOR' : 'Kullan';
                buttonColor = isSelected ? 'bg-green-600 hover:bg-green-700' : 'bg-blue-600 hover:bg-blue-700';
            } else {
                buttonText = `Satın Al - ${item.price} 💰`;
                buttonColor = canAfford ? 'bg-red-500 hover:bg-red-600' : 'bg-gray-600 cursor-not-allowed';
                if (!canAfford) disabled = 'disabled';
            }

            shopHtml += `
                <div class="flex justify-between items-center bg-gray-800 p-4 rounded-xl mb-3 shadow-md">
                    <div class="text-left flex-grow mr-2">
                        <span class="font-bold text-white text-lg">${item.name}</span> 
                        <span class="text-sm text-gray-400"> (Güç x${item.powerMultiplier.toFixed(1)})</span>
                        <p class="text-xs text-gray-400">${item.description}</p>
                    </div>
                    <button class="standard-button text-sm px-4 py-2 w-auto ${buttonColor} js-shop-item" data-type="cue" data-name="${item.name}" data-price="${item.price}" data-owned="${isOwned}" data-selected="${isSelected}" ${disabled}>
                        ${buttonText}
                    </button>
                </div>
            `;
        });
        
        shopHtml += `<h2 class="text-2xl font-semibold mt-6 mb-3 border-b border-gray-700 pb-1 text-left text-white">Toplar (Kozmetik)</h2>`;

        // Balls Section
        shopItems.balls.forEach(item => {
            const isOwned = playerData.ownedBalls.includes(item.name);
            const isSelected = playerData.selectedBall === item.name;
            const canAfford = playerData.coins >= item.price;
            
            let buttonText, buttonColor, disabled = '';

            if (isOwned) {
                buttonText = isSelected ? 'KULLANILIYOR' : 'Kullan';
                buttonColor = isSelected ? 'bg-green-600 hover:bg-green-700' : 'bg-blue-600 hover:bg-blue-700';
            } else {
                buttonText = `Satın Al - ${item.price} 💰`;
                buttonColor = canAfford ? 'bg-red-500 hover:bg-red-600' : 'bg-gray-600 cursor-not-allowed';
                if (!canAfford) disabled = 'disabled';
            }

            shopHtml += `
                <div class="flex justify-between items-center bg-gray-800 p-4 rounded-xl mb-3 shadow-md">
                    <div class="text-left flex-grow mr-2">
                        <div class="inline-block w-4 h-4 rounded-full mr-2" style="background-color: ${item.color}; border: 1px solid #fff;"></div>
                        <span class="font-bold text-white text-lg">${item.name}</span> 
                        <p class="text-xs text-gray-400">${item.description}</p>
                    </div>
                    <button class="standard-button text-sm px-4 py-2 w-auto ${buttonColor} js-shop-item" data-type="ball" data-name="${item.name}" data-price="${item.price}" data-owned="${isOwned}" data-selected="${isSelected}" ${disabled}>
                        ${buttonText}
                    </button>
                </div>
            `;
        });


        shopHtml += `
                    </div>
                    <!-- Tam ekran menülerdeki Geri butonu için game-button stili kullanıldı. -->
                    <button class="game-button bg-gray-500 hover:bg-gray-600 mt-10 js-button" data-action="main_menu">Geri</button>
                </div>
            </div>
        `;

        // Attach shop-specific listeners
        setTimeout(() => {
             document.querySelectorAll('.js-shop-item').forEach(button => {
                button.addEventListener('click', () => {
                    handleShopAction(button);
                });
            });
        }, 0);

        return shopHtml;
    }
    
    function handleShopAction(button) {
        const type = button.getAttribute('data-type');
        const name = button.getAttribute('data-name');
        const price = parseInt(button.getAttribute('data-price'));
        const isOwned = button.getAttribute('data-owned') === 'true';
        const isSelected = button.getAttribute('data-selected') === 'true';

        if (isOwned) {
            if (!isSelected) {
                // Eşyayı Kullan
                if (type === 'cue') {
                    playerData.selectedCue = name;
                    currentCue = shopItems.cues.find(c => c.name === name);
                } else if (type === 'ball') {
                    playerData.selectedBall = name;
                }
                saveGameData();
                showScreen('shop'); 
            }
        } else {
            // Satın Al
            if (playerData.coins >= price) {
                playerData.coins -= price;
                if (type === 'cue') {
                    playerData.ownedCues.push(name);
                    playerData.selectedCue = name;
                    currentCue = shopItems.cues.find(c => c.name === name);
                } else if (type === 'ball') {
                    playerData.ownedBalls.push(name);
                    playerData.selectedBall = name;
                }
                saveGameData();
                showScreen('shop'); 
                showMessageBox("Başarılı!", `${name} başarıyla satın alındı ve kullanıma ayarlandı.`);
            } else {
                showMessageBox("Yetersiz Para", `Bu ürünü satın almak için ${price - playerData.coins} 💰 daha gerekir.`);
            }
        }
    }
    
    // Mesaj kutusu (alert() yerine)
    function showMessageBox(title, message) {
        const container = document.getElementById('screenContainer');
        const prevScreen = currentScreen;
        container.style.display = 'flex';
        container.style.pointerEvents = 'auto';

        container.innerHTML = `
            <div class="bg-white p-6 shadow-2xl rounded-lg max-w-xs text-center mx-auto" style="z-index: 999; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);">
                <h3 class="text-2xl font-bold text-gray-800 mb-4">${title}</h3>
                <p class="text-gray-600 mb-6">${message}</p>
                <button id="msgBoxOk" class="standard-button bg-indigo-500 w-auto">ANLADIM</button>
            </div>
        `;
        
        container.style.opacity = '1';
        currentScreen = 'message_box'; 
        
        document.getElementById('msgBoxOk').addEventListener('click', () => {
            // Mesaj kutusu kapatıldığında eski ekrana dön
            showScreen(prevScreen); 
        });
    }


    // Initialize the game when the window loads
    window.onload = initializeGame;

    console.log("NOTE: This application uses localStorage instead of Firebase for persistence.");
</script>

</body>
</html>
